# CI/CD 툴 설치 가이드

## 목차

- [CI/CD 툴 설치 가이드](#cicd-툴-설치-가이드)
  - [목차](#목차)
  - [사전작업](#사전작업)
    - [리소스그룹과 Location 전역 설정](#리소스그룹과-location-전역-설정)
    - [AKS Node Pool 추가](#aks-node-pool-추가)
  - [Jenkins설치](#jenkins설치)
  - [SonarQube 설치](#sonarqube-설치)
  - [ArgoCD 설치](#argocd-설치)


| [Top](#목차) |

---

Window사용자는 Window Terminal의 GitBash 터미널에서 작업하고,   
Mac사용자는 맥 기본 터미널에서 작업합니다.   

## 사전작업

### 리소스그룹과 Location 전역 설정   
명령어에서 반복적으로 사용할 Resource Group과 Location값을 기본 설정에 셋팅합니다.   
Azure resource group을 확인합니다.  
```
az group list -o table
```

```
az configure -d group={리소스그룹} location={Location}
```
예시)
```
az configure -d group=tiu-dgga-rg location=koreacentral
```

설정된 값을 확인합니다.
```
az configure -l -o table
```

| [Top](#목차) |

  
### AKS Node Pool 추가  
**1.Node Pool 추가**     
Azure Portal에서 사용중인 AKS에 Node Pool을 추가합니다.       
- Node Pool명: cicd
- Mode: 사용자  
- Node size: DS2_v2   (2core / 7GB)
- node count: 1~3  

agentpool에 생성된 Node의 label을 확인합니다.  
```
k get nodes --show-labels | grep cicd

aks-cicd-25513482-vmss000000        Ready   <none>   8s      v1.30.9   agentpool=cicd,...
```

SonarQube 설치를 위한 NodePool 추가    
- Node Pool명: sonarqube
- Mode: 사용자  
- Node size: D4s_v3   (4core / 16GB)
- node count: 1  


**2.Taint설정: cicd**    
다른 user service용 Pod가 배포(Scheduling)되지 않도록 taint설정을 합니다.  

AKS 이름을 셋팅함  
```
export AKS_NAME=unicorn-aks
```

생성된 노드풀에 taint 설정을 합니다.   
```
az aks nodepool update --cluster-name ${AKS_NAME} --name cicd --node-taints dedicated=cicd:NoSchedule
```

Node의 Taint설정을 확인합니다.   
```
k describe node -l agentpool=cicd | grep -i taint
Taints:             dedicated=cicd:NoSchedule
```

**3.Taint설정: sonarqube**     
다른 user service용 Pod가 배포(Scheduling)되지 않도록 taint설정을 합니다.  
```
az aks nodepool update --cluster-name ${AKS_NAME} --name sonarqube --node-taints dedicated=sonarqube:NoSchedule
```

Node의 Taint설정을 확인합니다.   
```
k describe node -l agentpool=sonarqube | grep -i taint
Taints:             dedicated=sonarqube:NoSchedule
```

| [Top](#목차) |

---

## Jenkins설치

**1.Helm registry추가**    
```
helm repo add bitnami https://charts.bitnami.com/bitnami 
helm repo update
```

**2.Jenkins Helm chart 다운로드**     
```
mkdir -p ~/install && cd ~/install

helm search repo jenkins 

helm pull bitnami/jenkins

tar xvf {helm chart 압축파일명명}

cd jenkins
```

**3.설치 매니페스트 작성**    
설치를 위한 manifest 파일을 만듭니다.  
taint 설정이 되어 있으므로 Toleration설정을 통해 Pod가 생성되도록 합니다.  
```
cat > jenkins.yaml << EOF
global:
  storageClass: "managed"

jenkinsUser: admin
jenkinsPassword: "P@ssw0rd$"
jenkinsHost: "http://myjenkins.io"
jenkinsHome: /bitnami/jenkins/home

javaOpts:
  - -Dfile.encoding=UTF-8

agent:
  enabled: true

containerPorts:
  http: 8080
  https: 8443
  agentListener: 50000

agentListenerService:
  enabled: true
  type: ClusterIP
  ports:
    agentListener: 50000

persistence:
  enabled: true
  storageClass: "managed"
  accessModes:
    - ReadWriteOnce
  size: 8Gi

nodeSelector:
  agentpool: cicd

tolerations:
- key: "dedicated"
  operator: "Equal"
  value: "cicd"
  effect: "NoSchedule"
  
EOF
```

**4.설치**     
```
kubectl create ns jenkins

kubens jenkins

helm upgrade -i jenkins -f jenkins.yaml . --dry-run

helm upgrade -i jenkins -f jenkins.yaml .
```

Pod가 정상 실행될때까지 기다립니다.  
```
k get po -w
```

**5.hosts파일에 등록**   
'Window키 + d'를 눌러 바탕화면으로 이동합니다.  
아래와 같이 바로가기를 만듭니다.  이름은 'hosts'로 합니다.  
```
notepad "c:\windows\system32\drivers\etc\hosts"
```
![](images/2025-09-11-17-47-03.png)   

우측마우스 버튼 메뉴에서 '관리자 권한으로 실행하기'를 선택하여 엽니다.  

Jenkins 서비스 오브젝트의 external ip로 'myjenkins.io'을 등록합니다.  
```
k get svc

NAME                     TYPE           CLUSTER-IP     EXTERNAL-IP     
jenkins                  LoadBalancer   10.0.64.143    20.214.195.168 
```

예시)
```
# Jenkins
20.214.195.168	myjenkins.io
```

**6.플러그인 설치**    
https://myjenkins.io를 브라우저에서 엽니다.    
'admin'에 'P@ssw0rd$'로 로그인합니다.   

Plugins 메뉴를 클릭합니다.   
![](images/2025-09-11-17-47-35.png)    

아래 플러그인을 설치합니다.   
```
- Kubernetes
- Pipeline Utility Steps
- Docker Pipeline
- GitHub
- Blue Ocean
- SonarQube Scanner
- Azure Credentials
```

검색바에 위 플러그인을 검색하여 추가한 후 한꺼번에 설치 합니다.   
![](images/2025-09-11-17-48-02.png)     


설치가 끝나면 자동으로 재시작합니다.  
설치가 모두 끝났는대도 자동으로 재시작을 안하면 3~4분 정도 기다렸다가 전체화면을 리프레시 합니다.    
![](images/2025-09-11-17-49-03.png)     

**7.Kubernetes 연결 설정**     
아래 yaml을 'rbac.yaml'로 생성하고 적용합니다.  
```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: jenkins
  namespace: jenkins
```
Jenkins설치 시 생성된 Service Account 'jenkins'에 cluster-admin 역할을 부여하여  
AKS의 모든 객체를 관리할 수 있는 권한을 부여합니다.  
```
k apply -f rbac.yaml
```

'Dashboard > Manage Jenkins'메뉴에서 'Clouds'를 선택하고, 새로운 Cloud 프로파일을 작성합니다.  
아래 항목의 값만 입력합니다.  
```
- Kubernetes URL: https://kubernetes.default  
- Kubernetes Namespace: jenkins  
- Jenkins URL: http://jenkins
- Jenkins tunnel: jenkins-agent-listener:50000
```

System Configurations > Clouds 선택   
![](images/2025-09-11-17-50-06.png)  

Cloud name은 아무거나 입력   
![](images/2025-09-11-17-50-29.png)  

Kubernetes URL과 Kubernetes Namespace를 그림과 같이 입력   
![](images/2025-09-11-17-50-50.png)

Jenkins URL과 Jenkins tunnel을 그림과 같이 입력   
![](images/2025-09-11-17-51-46.png)    

하단 우측에 있는 '[Test Connection]'버튼을 클릭하여 연결되는 지 확인합니다.  

Jenkins URL과 Jenkins tunnel을 정확히 지정합니다.  
참고로 Jenkins URL과 Jenkins tunnel은 Service 오브젝트의 주소입니다.  
```
k get svc
NAME                     TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE
jenkins                  LoadBalancer   10.0.120.3    4.230.146.143   80:31237/TCP,443:31442/TCP   15m
jenkins-agent-listener   ClusterIP      10.0.61.235   <none>          50000/TCP                    15m
```
프로파일을 저장합니다.  

**8.Jenkins tunnel 포트 설정**    
'Dashboard > Manage Jenkins'메뉴에서 'Security'를 선택합니다.  
![](images/2025-09-11-17-52-41.png)    


**9.계정 및 권한관리**     
학습 목적으로 Jenkins를 사용한다면 admin user만 있으면 되므로 이 작업은 필요 없습니다.   
하지만 실무에 사용하려면 계정과 권한관리는 반드시 하셔야 합니다.   
아래 링크를 참조하세요.   
https://happycloud-lee.tistory.com/48  


**10.Service Principal 작성**: Azure 리소스 접근 권한 부여 받기   
**경고: 'Service Principal'는 이미 되어 있으므로 절대 수행하지 마세요.**    
**조금 밑으로 내려서 'Jenkins Credential에 Service Principal 등록'작업만 수행하세요**    

Jenkins Agent Pod에서 AKS와 ACR을 접근할 수 있는 권한을 먼저 부여해야 합니다.  
이 작업은 Azure Admin 권한이 있는 사람만이 할 수 있으므로 요청해야 합니다.  
이미 되어 있으므로 추가로 할 필요는 없으며 참고만 하십시오.   
- subscription id 구하기
```
az account show --query id -o tsv

df568535-0931-439d-a9ae-ca3601367d74
```

- ‘contributor’ 권한 생성 체크  
```
az ad sp list --display-name "jenkins-cicd" --query "[].{name:displayName, id:appId}" -o table
```

- ‘contributor’ 권한 부여  
**아래는 수행하지 마세요.**  
```
az ad sp create-for-rbac --name "jenkins-cicd" --role contributor --scopes /subscriptions/{subscription id} 
```

결과값 예시:
``` 
{
  "appId": "80d79cac-244c-4b58-a4a4-7705bdbd5551",
  "displayName": "jenkins-cicd",
  "password": "ulP8Q~ZyRlgA65uj_yEFHwQZOEiw96SP0~wm5b~u",
  "tenant": "a3870566-f011-4691-aa51-5b988c51c03a"
}
```

참고) Service principal 삭제
```
az ad sp delete --id $(az ad sp list --display-name "jenkins-cicd" --query "[].appId" -o tsv)
```
  
**11.Jenkins Credential에 Service Principal 등록**   

아래와 같이 동일하게 등록합니다.  
![](images/2025-09-11-18-12-58.png)

```
- Kind: Azure Service Principal
- Scope: Global
- Subscription ID: 2513dd36-7978-48e3-9a7c-b221d4874f66
- Client ID(appId 값): 5e4b5b41-7208-48b7-b821-d6d5acf50ecf
- Client Secret(password 값): ldu8Q~GQEzFYU.dJX7_QsahR7n7C2xqkIM6hqbV8
- Tenant ID: 4f0a3bfd-1156-4cce-8dc2-a049a13dba23
- Azure Environment: Azure
- ID/Description: Jenkinsfile 예제에 맞춰 ‘azure-credentials’로 등록
```
하단 우측의 ‘Verify Service Principal’ 클릭하여 테스트 하고 성공하면 ‘Create’를 눌러 등록함   
  
**12.ACR Credential 생성**    
아래 명령으로 암호를 획득합니다.   
```
az acr credential show -n {acr 이름}
```

```
az acr credential show -n unicorncr

{
  "passwords": [
    {
      "name": "password",
      "value": "lBPKfzh0q/eF/y1mJtcoFY1y3BT79LODSFuOJgMwTV+ACRAnHEXn"
    },
    {
      "name": "password2",
      "value": "dTDkQpAgTitcSF1PDavLRNyj+i/UdBebR3fAoDmMDu+ACRCkcvsR"
    }
  ],
  "username": "unicorncr"
}
```

Jenkins credential에 등록: 이름은 ‘acr-credentials’으로 등록   

![](images/2025-09-11-18-13-41.png)      


**13.DockerHub Credentials 생성**         
Pipeline 실행 시 DockerHub에서도 이미지를 내려 받기 때문에 인증정보를 등록해줘야 합니다.   
public image는 인증 없이도 내려받을수 있으나 횟수에 제한이 있어 등록해 줘야 합니다.    

1)Access Token생성     
DockerHub(https://hub.docker.com)에 로그인 합니다.    

Account Settings를 클릭   
![](images/2025-09-12-23-58-09.png) 

Personal Access Token을 생성합니다.   
![](images/2025-09-12-23-58-57.png)

![](images/2025-09-12-23-59-43.png) 

2)Jenkins Credentials 등록    
'dockerhub-credentials'라는 이름으로 등록합니다.
username은 Docker Hub 로그인 id 이고 암호는 위에서 만든 토큰을 입력합니다.      
![](images/2025-09-13-00-01-56.png)

| [Top](#목차) |

---

## SonarQube 설치

**1.Helm chart 다운로드**     
```
mkdir -p ~/install && cd ~/install
```

```
helm search repo sonarqube
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/sonarqube       8.0.3           25.2.0      
```

```
helm pull bitnami/sonarqube
```

```
tar xvf {helm chart 압축파일명}

cd sonarqube
```

**2.설치 manifest 파일 작성**    

```
cat > sonarqube.yaml << EOF
sonarqubeUsername: admin
sonarqubePassword: "sonarP@ssw0rd$"

service:
  type: LoadBalancer
  ports:
    http: 80
    elastic: 9001

persistence:
  enabled: true
  storageClass: "managed"
  accessModes: 
    - ReadWriteOnce
  size: 2Gi

nodeSelector:
  agentpool: sonarqube

tolerations:
- key: "dedicated"
  operator: "Equal"
  value: "sonarqube"
  effect: "NoSchedule"

postgresql:
  auth:
    password: "P@ssw0rd$"
    username: bn_sonarqube
  primary:
    persistence:
      storageClass: "managed"

resources:
  limits:
    cpu: "4"
    memory: "5Gi"
  requests:
    cpu: "3"
    memory: "4Gi"

image:
  registry: docker.io
  repository: bitnamilegacy/sonarqube
  tag: 25.5.0-debian-12-r0

sysctl:
  image:
    registry: docker.io
    repository: bitnamilegacy/os-shell
    tag: 12-debian-12-r51
    
EOF
```

charts/postgresql/values.yaml을 열어 아래 값으로 이미지 repository와 tag를 변경   
```
image:
  registry: docker.io
  repository: bitnamilegacy/postgresql
  tag: 17.4.0-debian-12-r17
```

**3.설치하기 **    
namespace 생성 후 이동
```
k create ns sonarqube
kubens sonarqube
```

설치하기
```
helm upgrade -i sonar -f sonarqube.yaml .
```

sonarqube Pod에서 affinity설정을 삭제합니다.   
postgresql DB와 동일 노드에 설치하는 affinity인데 DB Po가 다른 노드에 설치되기 때문에 Pod가 배포 안되기 때문입니다.   
```
kubectl patch deploy sonar-sonarqube --type=json -p='[{"op": "remove", "path": "/spec/template/spec/affinity"}]'
```

Pod 실행까지 기다립니다. 약 3~4분 걸립니다.   
```
watch kubectl get po
```

**4.접속하기**     

서비스 오브젝트의 External IP를 구하여 hosts에 등록합니다.  
```
k get svc
```

아래는 hosts 등록 예제입니다.   
```
# SonqrQube
20.249.64.146	mysonar.io
```

웹브라우저에서 접근합니다.   
로그인 ID는 지정한 'admin'이지만 초기 암호는 지정한 암호가 아니라 'admin'입니다.   
지정한 암호는 DB접속 암호로만 사용됩니다.    
초기 암호로 로그인하면 암호 변경 페이지가 나타납니다.   
12자 이상의 대문자, 특수문자, 숫자가 혼합된 암호(예: sonarP@ssw0rd$)로 지정합니다.    

**5.환경설정**    
1)User Token 발급     
MyAccount > Security에서 User Token발급
![](images/2025-09-12-14-09-55.png)  

![](images/2025-09-12-14-13-51.png). 

생성된 토큰값을 클립보드에 복사합니다.  

2)Jenkins Credential 등록   
Jenkins에 Credential을 위에서 만든 Token으로 만듭니다.  
![](images/2025-09-12-14-16-09.png).  

3)SonarQube Server설정  
System설정에서 SonarQube 서버 설정을 합니다.    
Jenkins에 플러그인 'SonaqQube Scanner'를 먼저 설치 해야 합니다.   

- Name: CI/CD파이프라인에서 참조할 이름입니다. 보통 SonarQube라고 합니다.  
- Server URL: Jenkins Pod에서 접근할 SonarQube 서비스의 주소. kubectl get svc -n sonarqube로 확인하고 다른 네임스페이스에 있으므로 전체 주소를 입력합니다.
- Authentication Token: 위에서 만든 credential 'sonarqube-access-token'을 선택

![](images/2025-09-12-14-19-08.png). 

4)Jenkins 통보 Webhook 작성   
SonarQube 품질 검사 결과를 Jenkins로 보내기 위해 Webhook을 만듭니다.  
![](images/2025-09-12-14-20-20.png)  

- name: 적절히 지정. 예) jenkins-webhook.  
- url: Jenkins 서버의 주소   
  Jenkins를 k8s에 설치한 경우 http://{service name}/sonarqube-webhook/ 으로 하고,   
  그냥 설치한 경우는 http://{IP 또는 host}/sonarqube-webhook으로 함

  ![](images/2025-09-12-14-21-01.png)


5)Quality Gate 작성    
SonarQube의 Quality Gate 복사하여 Custom 만들고 New code의 code coverage를 조정함.   
![](images/2025-09-12-14-23-24.png)  

'Sonar way'선택 후 우측 상단에서 '[Copy]'버튼 클릭    
![](images/2025-09-12-14-24-21.png)

적절한 이름을 부여합니다.  
![](images/2025-09-12-14-25-43.png)

작성한 Quality Gate를 선택하고 Code Coverage를 조정함.   
실습에서는 테스트 코드가 없으므로 '0'으로 함.  
![](images/2025-09-12-14-29-29.png)

| [Top](#목차) |

---

## ArgoCD 설치

**1.Ingress Controller 추가**   
Ingress Controller가 이미 설치되었는지 확인   
```
kubectl get po -n ingress-nginx  
```

만약 아직 설치 안했으면 아래 글을 참고하여 Ingress Controller부터 추가합니다.   
https://github.com/cna-bootcamp/clauding-guide/blob/main/README.md#ingress-controller-%EC%B6%94%EA%B0%80


**2.Helm registry 추가**   
```
helm repo add argo https://argoproj.github.io/argo-helm
helm repo update
```

**3.Helm chart 다운로드**     
```
mkdir -p ~/install && cd ~/install
```

```
helm search repo argocd

NAME                            CHART VERSION   APP VERSION 
argo/argocd-applicationset      1.12.1          v0.4.1       
argo/argocd-apps                2.0.2                        
argo/argocd-image-updater       0.12.0          v0.15.2      
argo/argocd-notifications       1.8.1           v1.2.1      
argo/argo-cd                    3.35.4          v2.2.5 
```

```
helm pull argo/argo-cd
```

```
tar xvf {helm chart 압축파일명}

cd argo-cd
```

**4.설치 manifest 파일 작성**     
ingress-nginx-controller 서비스 오브젝트의 external ip를 구합니다.  

```
k get svc -n ingress-nginx

NAME                                 TYPE           CLUSTER-IP     EXTERNAL-IP    
ingress-nginx-controller             LoadBalancer   10.0.160.107   20.249.128.1 
```

아래 예와 같이 위에서 구한 external ip값을 지정합니다.  
```
export ING_IP=20.214.196.128
```

manifest파일을 작성합니다.   
```
cat > argocd.yaml << EOF
global:
  domain: argo.$ING_IP.nip.io
  
  nodeSelector:
    agentpool: cicd

  tolerations:
  - key: "dedicated"
    operator: "Equal"
    value: "cicd"
    effect: "NoSchedule"
  
server:
  ingress:
    enabled: true
    https: true
    annotations:
      kubernetes.io/ingress.class: nginx
    tls:
      - secretName: argocd-tls-secret
  extraArgs:
    - --insecure  # ArgoCD 서버가 TLS 종료를 Ingress에 위임

configs:
  params:
    server.insecure: true  # Ingress에서 TLS를 처리하므로 ArgoCD 서버는 HTTP로 통신
certificate:
  enabled: false  # 자체 서명 인증서 사용 비활성화 (외부 인증서 사용 시)
EOF
```

**5.namespace 작성**    

```
k create ns argocd
kubens argocd
```


**6.TLS 인증서 작성 및 Secret 객체 작성**      
```
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=argo.$ING_IP.nip.io"

kubectl create secret tls argocd-tls-secret \
  --namespace argocd \
  --key tls.key \
  --cert tls.crt
```

**7.설치하기**    
```
helm upgrade -i argocd -f argocd.yaml .
```

**8.접속하기**     
위 manifest에서 지정한 host name으로 접속합니다.   
예) https://argo.20.249.128.1.nip.io  

ID는 admin이고 초기 암호는 아래와 같이 구합니다.   
```
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo
```

비밀번호는 로그인 후 'User Info'에서 변경할 수 있습니다.    



| [Top](#목차) |

---

